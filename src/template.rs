use std::collections::HashMap;

use anyhow::{bail, Result};

use crate::parser::RequestTemplate;

pub fn render_export_template(name: &str, template: &RequestTemplate) -> Result<String> {
    match name {
        "js-fetch" => render_js_fetch(template),
        other => bail!("Unknown export template: {other}"),
    }
}

fn render_js_fetch(template: &RequestTemplate) -> Result<String> {
    let headers_map: HashMap<_, _> = template.headers.iter().cloned().collect();
    let headers_block = if headers_map.is_empty() {
        String::new()
    } else {
        let json = serde_json::to_string_pretty(&headers_map)?;
        format!(",\n    headers: {json}")
    };

    let body_block = if let Some(body_file) = &template.body_file {
        format!(
            ",\n    // TODO: provide body manually. Original file: {}",
            body_file.display()
        )
    } else if let Some(body_text) = &template.body_text {
        let json = serde_json::to_string(body_text)?;
        format!(",\n    body: {json}")
    } else {
        String::new()
    };

    let method = template.method.to_uppercase();
    let url = serde_json::to_string(&template.url)?;

    Ok(format!(
        r#"// Generated by curlpit
export async function runRequest() {{
  const response = await fetch({url}, {{
    method: "{method}"{headers_block}{body_block}
  }});

  if (!response.ok) {{
    throw new Error(`Request failed: ${{response.status}} ${{response.statusText}}`);
  }}

  return response;
}}
"#
    ))
}
